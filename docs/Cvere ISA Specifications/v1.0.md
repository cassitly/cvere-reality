# CVERE Instruction Set Architecture (ISA) Specification v1.0

## Overview

CVERE (Computer Virtualization and Execution Reality Engine) is a hexadecimal-based instruction set architecture designed for educational visualization and simulation. It uses a 16-bit instruction format with hexadecimal encoding for human readability.

## Design Philosophy

- **Hex-Native**: All instructions, registers, and addresses are represented in hexadecimal
- **Visual-First**: Designed to be easily visualized in datapath diagrams
- **RISC-Inspired**: Simple, regular instruction format
- **Educational**: Clear separation of instruction types and pipeline stages

## Architecture Specifications

### Register File

**16 General Purpose Registers** (4-bit addressing)
```
R0 (0x0) - Always reads as 0x0000, writes ignored (zero register)
R1 (0x1) - General purpose
R2 (0x2) - General purpose
...
RF (0xF) - General purpose
```

**Special Purpose Registers**
```
PC   - Program Counter (16-bit)
SP   - Stack Pointer (16-bit)
LR   - Link Register (for function calls)
SR   - Status Register (flags: Z, N, C, V, etc.)
```

### Status Register Flags

```
Bit 0 (Z): Zero flag
Bit 1 (N): Negative flag
Bit 2 (C): Carry flag
Bit 3 (V): Overflow flag
Bit 4-15: Reserved
```

### Memory Model

- **Address Space**: 16-bit (64KB addressable)
- **Word Size**: 16-bit (2 bytes)
- **Endianness**: Little-endian
- **Alignment**: Instructions must be word-aligned (even addresses)

## Instruction Format

All instructions are **16 bits (4 hex digits)** with the following formats:

### Format Types

#### R-Type (Register Operations)
```
┌────┬────┬────┬────┐
│ Op │ Rd │ Rs │ Rt │
└────┴────┴────┴────┘
 4bit 4bit 4bit 4bit

Example: ADD R3, R1, R2 → 0x1312
```

#### I-Type (Immediate Operations)
```
┌────┬────┬────────┐
│ Op │ Rd │  Imm8  │
└────┴────┴────────┘
 4bit 4bit   8bit

Example: ADDI R3, 0x42 → 0x2342
```

#### M-Type (Memory Operations)
```
┌────┬────┬────┬────┐
│ Op │ Rd │ Rs │Off │
└────┴────┴────┴────┘
 4bit 4bit 4bit 4bit

Example: LOAD R3, R1, 0x4 → 0x5314
```

#### J-Type (Jump Operations)
```
┌────┬────────────┐
│ Op │   Addr12   │
└────┴────────────┘
 4bit    12bit

Example: JMP 0x100 → 0xA100
```

#### B-Type (Branch Operations)
```
┌────┬────┬────────┐
│ Op │ Rc │ Offset │
└────┴────┴────────┘
 4bit 4bit   8bit

Example: BEQ R1, 0x10 → 0xB110
```

## Instruction Set

### Arithmetic Operations (0x0 - 0x3)

| Opcode | Mnemonic | Format | Description | Operation |
|--------|----------|--------|-------------|-----------|
| 0x0    | NOP      | -      | No operation | PC += 2 |
| 0x1    | ADD      | R-Type | Add registers | Rd = Rs + Rt |
| 0x2    | ADDI     | I-Type | Add immediate | Rd = Rd + Imm8 |
| 0x3    | SUB      | R-Type | Subtract | Rd = Rs - Rt |

### Logical Operations (0x4 - 0x7)

| Opcode | Mnemonic | Format | Description | Operation |
|--------|----------|--------|-------------|-----------|
| 0x4    | AND      | R-Type | Bitwise AND | Rd = Rs & Rt |
| 0x5    | OR       | R-Type | Bitwise OR | Rd = Rs \| Rt |
| 0x6    | XOR      | R-Type | Bitwise XOR | Rd = Rs ^ Rt |
| 0x7    | NOT      | R-Type | Bitwise NOT | Rd = ~Rs |

### Shift Operations (0x8 - 0x9)

| Opcode | Mnemonic | Format | Description | Operation |
|--------|----------|--------|-------------|-----------|
| 0x8    | SHL      | R-Type | Shift left | Rd = Rs << Rt |
| 0x9    | SHR      | R-Type | Shift right | Rd = Rs >> Rt |

### Memory Operations (0xA - 0xC)

| Opcode | Mnemonic | Format | Description | Operation |
|--------|----------|--------|-------------|-----------|
| 0xA    | LOAD     | M-Type | Load from memory | Rd = Mem[Rs + Off] |
| 0xB    | STORE    | M-Type | Store to memory | Mem[Rs + Off] = Rd |
| 0xC    | LOADI    | I-Type | Load immediate | Rd = SignExt(Imm8) |

### Control Flow (0xD - 0xF)

| Opcode | Mnemonic | Format | Description | Operation |
|--------|----------|--------|-------------|-----------|
| 0xD    | JMP      | J-Type | Unconditional jump | PC = Addr12 |
| 0xE    | BEQ      | B-Type | Branch if equal | if (Rc == 0) PC += SignExt(Offset) |
| 0xF    | BNE      | B-Type | Branch if not equal | if (Rc != 0) PC += SignExt(Offset) |

### Extended Operations (Two-word instructions)

For operations requiring more complexity, use two consecutive words:

| Opcode | Mnemonic | Format | Description |
|--------|----------|--------|-------------|
| 0xF0xx | CALL     | Extended | Function call |
| 0xF1xx | RET      | Extended | Return from function |
| 0xF2xx | PUSH     | Extended | Push to stack |
| 0xF3xx | POP      | Extended | Pop from stack |
| 0xFFFF | HALT     | Special | Stop execution |

## Assembly Language Syntax

### Basic Syntax
```asm
; Comments start with semicolon
LABEL:  MNEMONIC  operands  ; inline comment

; Examples:
start:  LOADI R1, 0x42      ; Load 0x42 into R1
        ADDI  R1, 0x10      ; Add 0x10 to R1
        STORE R1, R0, 0x0   ; Store to memory[0]
```

### Register Naming
- Hexadecimal: `R0` through `RF` (or `R0-R15`)
- Special: `PC`, `SP`, `LR`, `SR`

### Immediate Values
- Decimal: `42`
- Hexadecimal: `0x2A` or `0h2A`
- Binary: `0b101010`

### Labels and Addresses
```asm
loop:   LOAD  R1, R2, 0x0
        ADDI  R1, 0x1
        BNE   R1, loop      ; Branch to loop if R1 != 0
```

## Example Programs

### Example 1: Simple Addition
```asm
; Add two numbers
start:
    LOADI R1, 0x05      ; R1 = 5
    LOADI R2, 0x03      ; R2 = 3
    ADD   R3, R1, R2    ; R3 = R1 + R2
    HALT
```

**Machine Code:**
```hex
0xC105  ; LOADI R1, 0x05
0xC203  ; LOADI R2, 0x03
0x1312  ; ADD R3, R1, R2
0xFFFF  ; HALT
```

### Example 2: Loop Counter
```asm
; Count from 0 to 10
start:
    LOADI R1, 0x00      ; Counter = 0
    LOADI R2, 0x0A      ; Limit = 10
loop:
    ADDI  R1, 0x01      ; Counter++
    SUB   R3, R2, R1    ; R3 = Limit - Counter
    BNE   R3, loop      ; If R3 != 0, continue
    HALT
```

### Example 3: Array Sum
```asm
; Sum array of 4 elements
start:
    LOADI R1, 0x00      ; Sum = 0
    LOADI R2, 0x10      ; Base address
    LOADI R3, 0x04      ; Count = 4
loop:
    LOAD  R4, R2, 0x0   ; Load array[i]
    ADD   R1, R1, R4    ; Sum += array[i]
    ADDI  R2, 0x02      ; Next address (word-aligned)
    ADDI  R3, 0xFF      ; Count-- (0xFF = -1 in 8-bit)
    BNE   R3, loop
    STORE R1, R0, 0x20  ; Store result at 0x20
    HALT
```

## Pipeline Stages

CVERE uses a 5-stage pipeline:

1. **IF (Instruction Fetch)**: Fetch instruction from memory at PC
2. **ID (Instruction Decode)**: Decode opcode and read registers
3. **EX (Execute)**: Perform ALU operation or calculate address
4. **MEM (Memory Access)**: Read/write memory for LOAD/STORE
5. **WB (Write Back)**: Write result to register file

### Pipeline Hazards

**Data Hazards**: Forwarding paths from EX/MEM/WB stages to EX stage
**Control Hazards**: Branch prediction (predict not-taken)
**Structural Hazards**: Single memory port causes stall on LOAD/STORE

## Encoding Reference

### Quick Opcode Table
```
0x0: NOP    0x4: AND    0x8: SHL    0xC: LOADI
0x1: ADD    0x5: OR     0x9: SHR    0xD: JMP
0x2: ADDI   0x6: XOR    0xA: LOAD   0xE: BEQ
0x3: SUB    0x7: NOT    0xB: STORE  0xF: BNE/Extended
```

### Instruction Encoding Patterns

**R-Type Pattern**: `[Op:4][Rd:4][Rs:4][Rt:4]`
- ADD R3, R1, R2 → `0001 0011 0001 0010` → `0x1312`

**I-Type Pattern**: `[Op:4][Rd:4][Imm:8]`
- LOADI R5, 0x42 → `1100 0101 01000010` → `0xC542`

**M-Type Pattern**: `[Op:4][Rd:4][Rs:4][Off:4]`
- LOAD R3, R2, 0x4 → `1010 0011 0010 0100` → `0xA324`

## Calling Convention

### Function Prologue
```asm
function:
    PUSH LR             ; Save return address
    PUSH R1             ; Save registers
    PUSH R2
    ; Function body
```

### Function Epilogue
```asm
    POP  R2             ; Restore registers
    POP  R1
    POP  LR
    RET                 ; Return
```

### Argument Passing
- First 4 arguments: R1-R4
- Additional arguments: Stack
- Return value: R1

## Future Extensions

- Floating point operations (F-Type format)
- Vector instructions (SIMD)
- Privilege levels and system calls
- Cache control instructions
- Atomic operations for multicore

---

**Version**: 1.0  
**Last Updated**: 2026-01-08  
**Status**: Draft for Implementation